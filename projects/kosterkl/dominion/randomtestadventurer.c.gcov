        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************
        -:    2:* Assignment 4: Random testing
        -:    3:* File: randomtestadventurer.c
        -:    4:* Card in Test: adventurer
        -:    5:*
        -:    6:* Author: Klaus Koster (kosterkl)
        -:    7:* Due Date: 11/14/2018
        -:    8:* CS 362, Fall 2018
        -:    9:*******************************************************************/
        -:   10:
        -:   11:// include files
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "interface.h"
        -:   15:#include "rngs.h"
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:#include <time.h>
        -:   20:
        -:   21:/************************************************************
        -:   22:            ADVENTURER
        -:   23:
        -:   24:Expected behavior: Draw cards until getting 2 additional treasure cards. Discard the other non-treasure drawn cards.
        -:   25:
        -:   26:Input:
        -:   27:    int currentPlayer,
        -:   28:    int temphand[]
        -:   29:    struct gameState *state
        -:   30:
        -:   31:Output:
        -:   32:    int (return 0)
        -:   33:************************************************************/
        -:   34:
        -:   35:#define TESTCARD "Adventurer"
        -:   36:#define TEST_ITERATIONS 2000
        -:   37:
        -:   38:
        -:   39:struct compareGame
        -:   40:{
        -:   41:    int handCount;
        -:   42:    int deckCount;
        -:   43:    int playedCardCount;
        -:   44:    int playedSuccessfully;
        -:   45:    int numActions;
        -:   46:    int numBuys;
        -:   47:
        -:   48:    // this represents ALL game cards (both victory and regular kingdom cards)
        -:   49:    // So, iterating over the entire things is checking all the cards in the game for state changes
        -:   50:    int gameCards[treasure_map + 1];
        -:   51:    char* gameCardNames[treasure_map + 1];
        -:   52:};
        -:   53:
        -:   54:void asserttrue(int value, char* test, int before, int after);
        -:   55:
        -:   56:
function main called 1 returned 100% blocks executed 100%
        1:   57:int main(int argc, char* argv[])
        -:   58:{
        -:   59:    time_t timeSeed;
        1:   60:    srand((unsigned) time(&timeSeed));
call    0 returned 100%
call    1 returned 100%
        1:   61:    int timesPlayedSuccessfully = 0;
        1:   62:    int timesCorrectHandCount = 0;
        -:   63:
        1:   64:    printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        1:   65:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:   66:
        -:   67:    int i;
     2001:   68:    for (i = 0; i < TEST_ITERATIONS; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   69:    {
        -:   70:        // setup our variables/things necessary to start and play the game/card
        -:   71:        struct gameState state;
        -:   72:        struct compareGame before;
        -:   73:        struct compareGame after;
     2000:   74:        before.gameCardNames[0] = "curse";
     2000:   75:        before.gameCardNames[1] = "estate";
     2000:   76:        before.gameCardNames[2] = "duchy";
     2000:   77:        before.gameCardNames[3] = "province";
     2000:   78:        before.gameCardNames[4] = "copper";
     2000:   79:        before.gameCardNames[5] = "silver";
     2000:   80:        before.gameCardNames[6] = "gold";
     2000:   81:        before.gameCardNames[7] = "adventurer";
     2000:   82:        before.gameCardNames[8] = "council_room";
     2000:   83:        before.gameCardNames[9] = "feast";
     2000:   84:        before.gameCardNames[10] = "gardens";
     2000:   85:        before.gameCardNames[11] = "mine";
     2000:   86:        before.gameCardNames[12] = "remodel";
     2000:   87:        before.gameCardNames[13] = "smithy";
     2000:   88:        before.gameCardNames[14] = "village";
     2000:   89:        before.gameCardNames[15] = "baron";
     2000:   90:        before.gameCardNames[16] = "great_hall";
     2000:   91:        before.gameCardNames[17] = "minion";
     2000:   92:        before.gameCardNames[18] = "steward";
     2000:   93:        before.gameCardNames[19] = "tribute";
     2000:   94:        before.gameCardNames[20] = "ambassador";
     2000:   95:        before.gameCardNames[21] = "cutpurse";
     2000:   96:        before.gameCardNames[22] = "embargo";
     2000:   97:        before.gameCardNames[23] = "outpost";
     2000:   98:        before.gameCardNames[24] = "salvager";
     2000:   99:        before.gameCardNames[25] = "sea_hag";
     2000:  100:        before.gameCardNames[26] = "treasure_map";
     2000:  101:        int k[10] = { adventurer, council_room, cutpurse, embargo, gardens, minion, mine, village, smithy, tribute };
     2000:  102:        int numPlayers = 2;     // I was going to randomize this too, but this would change testing, likely a nested for loop to compare each player
     2000:  103:        int handPosition = 0;
        -:  104:        // no choices or bonus for smithy card
     2000:  105:        int choice1 = 0;
     2000:  106:        int choice2 = 0;
     2000:  107:        int choice3 = 0;
     2000:  108:        int bonus = 0;
        -:  109:        char gameCardString[100];
        -:  110:
     2000:  111:        int seed = rand();
call    0 returned 100%
        -:  112:
        -:  113:        // initialize the game
     2000:  114:        initializeGame(numPlayers, k, seed, &state);
call    0 returned 100%
        -:  115:
        -:  116:        // get initial state of the game before playing smithy
     2000:  117:        before.handCount = numHandCards(&state);
call    0 returned 100%
     2000:  118:        before.deckCount = state.deckCount[0];		// player 0's (1st player) deck count
     2000:  119:        before.playedCardCount = state.playedCardCount;
     2000:  120:        before.numActions = state.numActions;
     2000:  121:        before.playedSuccessfully = 0;
     2000:  122:        before.numBuys = state.numBuys;
        -:  123:
     2000:  124:        int i = 0;
    56000:  125:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  126:        {
    54000:  127:            before.gameCards[i] = state.supplyCount[i];
        -:  128:        }
        -:  129:
        -:  130:        // play smithy card
     2000:  131:        after.playedSuccessfully = cardEffect(adventurer, choice1, choice2, choice3, &state, handPosition, &bonus);
call    0 returned 100%
     2000:  132:        asserttrue(before.playedSuccessfully == after.playedSuccessfully, "Card played", before.playedSuccessfully, after.playedSuccessfully);
call    0 returned 100%
        -:  133:        
     2000:  134:        if(after.playedSuccessfully == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  135:            timesPlayedSuccessfully++;
        -:  136:
        -:  137:        // update test struct after playing
     2000:  138:        after.handCount = numHandCards(&state);
call    0 returned 100%
     2000:  139:        after.deckCount = state.deckCount[0];
     2000:  140:        after.playedCardCount = state.playedCardCount;
     2000:  141:        after.numActions = state.numActions;
     2000:  142:        after.numBuys = state.numBuys;
        -:  143:
    56000:  144:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  145:        {
    54000:  146:            after.gameCards[i] = state.supplyCount[i];
        -:  147:        }
        -:  148:
        -:  149:        // begin assertions and printing results
     2000:  150:        asserttrue((after.handCount - before.handCount) == 2, "Hand Count", before.handCount, after.handCount);
call    0 returned 100%
        -:  151:        
     2000:  152:        if((after.handCount - before.handCount) == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  153:            timesCorrectHandCount++;
        -:  154:
        -:  155:        // removed deck count as this could be any number of cards removed from the deck
        -:  156:        // possible bug in played card count in adventurer as well - this never calls discard card, thus playedcards doesn't get incremented.  Leaving test in as a good test!
     2000:  157:        asserttrue((after.playedCardCount - before.playedCardCount) == 1, "Played Card Count", before.playedCardCount, after.playedCardCount);
call    0 returned 100%
     2000:  158:        asserttrue((before.numActions - after.numActions) == 0, "Number of Actions Count", before.numActions, after.numActions);
call    0 returned 100%
     2000:  159:        asserttrue(before.numBuys == after.numBuys, "Number of Buys Count", before.numBuys, after.numBuys);
call    0 returned 100%
        -:  160:
    56000:  161:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  162:        {
    54000:  163:            memset(gameCardString, '\0', 100 * sizeof(char));
    54000:  164:            strcpy(gameCardString, "Game Card Count for: ");
    54000:  165:            strcat(gameCardString, before.gameCardNames[i]);
    54000:  166:            asserttrue(before.gameCards[i] == after.gameCards[i], gameCardString, before.gameCards[i], after.gameCards[i]);
call    0 returned 100%
        -:  167:        }
        -:  168:    }
        -:  169:
        1:  170:    printf("Number of iterations: %d\t Played Successfully: %d\n", TEST_ITERATIONS, timesPlayedSuccessfully);
call    0 returned 100%
        1:  171:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  172:
        1:  173:    printf("Number of iterations: %d\t Number of Iterations with Correct Hand Count: %d\n", TEST_ITERATIONS, timesCorrectHandCount);
call    0 returned 100%
        1:  174:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  175:
        1:  176:    return 0;
        -:  177:}
        -:  178:
function asserttrue called 64000 returned 100% blocks executed 100%
    64000:  179:void asserttrue(int value, char* test, int before, int after)
        -:  180:{
    64000:  181:    if (value)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:  182:    {
    62000:  183:        printf("Test: %s successful!\n", test);
call    0 returned 100%
    62000:  184:        printf("Before: %d\tAfter: %d\n", before, after);
call    0 returned 100%
    62000:  185:        fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  186:    }
        -:  187:    else
        -:  188:    {
     2000:  189:        printf("Test: %s failed!\n", test);
call    0 returned 100%
     2000:  190:        printf("Before: %d\tAfter: %d\n", before, after);
call    0 returned 100%
     2000:  191:        fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  192:    }
    64000:  193:}
