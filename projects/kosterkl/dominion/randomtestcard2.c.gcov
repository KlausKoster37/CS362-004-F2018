        -:    0:Source:randomtestcard2.c
        -:    0:Graph:randomtestcard2.gcno
        -:    0:Data:randomtestcard2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************
        -:    2:* Assignment 4: Random Testing
        -:    3:* File: randomcardtest2.c
        -:    4:* Card in Test: council room
        -:    5:*
        -:    6:* Author: Klaus Koster (kosterkl)
        -:    7:* Due Date: 11/14/2018
        -:    8:* CS 362, Fall 2018
        -:    9:*******************************************************************/
        -:   10:
        -:   11:// include files
        -:   12:#include "dominion.h"
        -:   13:#include "dominion_helpers.h"
        -:   14:#include "interface.h"
        -:   15:#include "rngs.h"
        -:   16:#include <stdio.h>
        -:   17:#include <stdlib.h>
        -:   18:#include <string.h>
        -:   19:#include <time.h>
        -:   20:
        -:   21:/************************************************************
        -:   22:            COUNCIL ROOM
        -:   23:
        -:   24:Expected behavior: Draw 4 cards, +1 Buy, each other player draws a card
        -:   25:    Note: +3 cards (+4, discard 1)
        -:   26:
        -:   27:Input:
        -:   28:    int currentPlayer,
        -:   29:    int handPos,
        -:   30:    struct gameState *state
        -:   31:
        -:   32:Output:
        -:   33:    int (return 0)
        -:   34:************************************************************/
        -:   35:
        -:   36:#define TESTCARD "Council Room"
        -:   37:#define TEST_ITERATIONS 2000
        -:   38:
        -:   39:
        -:   40:struct compareGame
        -:   41:{
        -:   42:    int handCount;
        -:   43:    int deckCount;
        -:   44:    int playedCardCount;
        -:   45:    int playedSuccessfully;
        -:   46:    int numActions;
        -:   47:    int numBuys;
        -:   48:
        -:   49:    // this represents ALL game cards (both victory and regular kingdom cards)
        -:   50:    // So, iterating over the entire things is checking all the cards in the game for state changes
        -:   51:    int gameCards[treasure_map + 1];
        -:   52:    char* gameCardNames[treasure_map + 1];
        -:   53:};
        -:   54:
        -:   55:void asserttrue(int value, char* test, int before, int after);
        -:   56:
        -:   57:
function main called 1 returned 100% blocks executed 100%
        1:   58:int main(int argc, char* argv[])
        -:   59:{
        -:   60:    time_t timeSeed;
        1:   61:    srand((unsigned) time(&timeSeed));
call    0 returned 100%
call    1 returned 100%
        1:   62:    int timesPlayedSuccessfully = 0;
        1:   63:    int timesCorrectHandCount = 0;
        1:   64:    int timesCorrectDeckCount = 0;
        1:   65:    int timesCorrectBuyCount = 0;
        -:   66:
        1:   67:    printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        1:   68:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:   69:
        -:   70:    int i;
     2001:   71:    for (i = 0; i < TEST_ITERATIONS; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   72:    {
        -:   73:        // setup our variables/things necessary to start and play the game/card
        -:   74:        struct gameState state;
        -:   75:        struct compareGame before;
        -:   76:        struct compareGame after;
     2000:   77:        before.gameCardNames[0] = "curse";
     2000:   78:        before.gameCardNames[1] = "estate";
     2000:   79:        before.gameCardNames[2] = "duchy";
     2000:   80:        before.gameCardNames[3] = "province";
     2000:   81:        before.gameCardNames[4] = "copper";
     2000:   82:        before.gameCardNames[5] = "silver";
     2000:   83:        before.gameCardNames[6] = "gold";
     2000:   84:        before.gameCardNames[7] = "adventurer";
     2000:   85:        before.gameCardNames[8] = "council_room";
     2000:   86:        before.gameCardNames[9] = "feast";
     2000:   87:        before.gameCardNames[10] = "gardens";
     2000:   88:        before.gameCardNames[11] = "mine";
     2000:   89:        before.gameCardNames[12] = "remodel";
     2000:   90:        before.gameCardNames[13] = "smithy";
     2000:   91:        before.gameCardNames[14] = "village";
     2000:   92:        before.gameCardNames[15] = "baron";
     2000:   93:        before.gameCardNames[16] = "great_hall";
     2000:   94:        before.gameCardNames[17] = "minion";
     2000:   95:        before.gameCardNames[18] = "steward";
     2000:   96:        before.gameCardNames[19] = "tribute";
     2000:   97:        before.gameCardNames[20] = "ambassador";
     2000:   98:        before.gameCardNames[21] = "cutpurse";
     2000:   99:        before.gameCardNames[22] = "embargo";
     2000:  100:        before.gameCardNames[23] = "outpost";
     2000:  101:        before.gameCardNames[24] = "salvager";
     2000:  102:        before.gameCardNames[25] = "sea_hag";
     2000:  103:        before.gameCardNames[26] = "treasure_map";
     2000:  104:        int k[10] = { adventurer, council_room, cutpurse, embargo, gardens, minion, mine, village, smithy, tribute };
     2000:  105:        int numPlayers = 2;
     2000:  106:        int handPosition = 0;
     2000:  107:        int seed = rand();
call    0 returned 100%
        -:  108:        // no choices or bonus for council room card
     2000:  109:        int choice1 = 0;
     2000:  110:        int choice2 = 0;
     2000:  111:        int choice3 = 0;
     2000:  112:        int bonus = 0;
        -:  113:        char gameCardString[100];
        -:  114:
        -:  115:        // initialize the game
     2000:  116:        initializeGame(numPlayers, k, seed, &state);
call    0 returned 100%
        -:  117:
        -:  118:        // get initial state of the game before playing smithy
     2000:  119:        before.handCount = numHandCards(&state);
call    0 returned 100%
     2000:  120:        before.deckCount = state.deckCount[0];		// player 0's (1st player) deck count
     2000:  121:        before.playedCardCount = state.playedCardCount;
     2000:  122:        before.numActions = state.numActions;
     2000:  123:        before.playedSuccessfully = 0;
     2000:  124:        before.numBuys = state.numBuys;
        -:  125:
     2000:  126:        int i = 0;
    56000:  127:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  128:        {
    54000:  129:            before.gameCards[i] = state.supplyCount[i];
        -:  130:        }
        -:  131:
        -:  132:        // play smithy card
     2000:  133:        after.playedSuccessfully = cardEffect(council_room, choice1, choice2, choice3, &state, handPosition, &bonus);
call    0 returned 100%
     2000:  134:        asserttrue(before.playedSuccessfully == after.playedSuccessfully, "Card played", before.playedSuccessfully, after.playedSuccessfully);
call    0 returned 100%
        -:  135:
     2000:  136:        if(after.playedSuccessfully == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  137:            timesPlayedSuccessfully++;
        -:  138:
        -:  139:        // update test struct after playing
     2000:  140:        after.handCount = numHandCards(&state);
call    0 returned 100%
     2000:  141:        after.deckCount = state.deckCount[0];
     2000:  142:        after.playedCardCount = state.playedCardCount;
     2000:  143:        after.numActions = state.numActions;
     2000:  144:        after.numBuys = state.numBuys;
        -:  145:
    56000:  146:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  147:        {
    54000:  148:            after.gameCards[i] = state.supplyCount[i];
        -:  149:        }
        -:  150:
        -:  151:        // begin assertions and printing results
        -:  152:        // note that bug 3 is caught via the played card count since we altered the trash flag, the state played card count doesn't increase
     2000:  153:        asserttrue((after.handCount - before.handCount) == 3, "Hand Count", before.handCount, after.handCount);
call    0 returned 100%
        -:  154:
     2000:  155:        if((after.handCount - before.handCount) == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  156:            timesCorrectHandCount++;
        -:  157:
     2000:  158:        asserttrue((before.deckCount - after.deckCount) == 4, "Deck Count", before.deckCount, after.deckCount);
call    0 returned 100%
        -:  159:
     2000:  160:        if((before.deckCount - after.deckCount) == 4)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  161:            timesCorrectDeckCount++;
        -:  162:
     2000:  163:        asserttrue((after.playedCardCount - before.playedCardCount) == 1, "Played Card Count", before.playedCardCount, after.playedCardCount);
call    0 returned 100%
     2000:  164:        asserttrue((before.numActions - after.numActions) == 0, "Number of Actions Count", before.numActions, after.numActions);
call    0 returned 100%
     2000:  165:        asserttrue((after.numBuys - before.numBuys) == 1, "Number of Buys Count", before.numBuys, after.numBuys);
call    0 returned 100%
        -:  166:
     2000:  167:        if((after.numBuys - before.numBuys) == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2000:  168:            timesCorrectBuyCount++;
        -:  169:
    56000:  170:        for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  171:        {
    54000:  172:            memset(gameCardString, '\0', 100 * sizeof(char));
    54000:  173:            strcpy(gameCardString, "Game Card Count for: ");
    54000:  174:            strcat(gameCardString, before.gameCardNames[i]);
    54000:  175:            asserttrue(before.gameCards[i] == after.gameCards[i], gameCardString, before.gameCards[i], after.gameCards[i]);
call    0 returned 100%
        -:  176:        }
        -:  177:    }
        -:  178:
        1:  179:    printf("Number of iterations: %d\t Played Successfully: %d\n", TEST_ITERATIONS, timesPlayedSuccessfully);
call    0 returned 100%
        1:  180:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  181:
        1:  182:    printf("Number of iterations: %d\t Number of Iterations with Correct Hand Count: %d\n", TEST_ITERATIONS, timesCorrectHandCount);
call    0 returned 100%
        1:  183:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  184:
        1:  185:    printf("Number of iterations: %d\t Number of Iterations with Correct Deck Count: %d\n", TEST_ITERATIONS, timesCorrectDeckCount);
call    0 returned 100%
        1:  186:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  187:
        1:  188:    printf("Number of iterations: %d\t Number of Iterations with Correct Buy Count: %d\n", TEST_ITERATIONS, timesCorrectBuyCount);
call    0 returned 100%
        1:  189:    fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  190:
        1:  191:    return 0;
        -:  192:}
        -:  193:
function asserttrue called 66000 returned 100% blocks executed 100%
    66000:  194:void asserttrue(int value, char* test, int before, int after)
        -:  195:{
    66000:  196:    if (value)
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:  197:    {
    64000:  198:        printf("Test: %s successful!\n", test);
call    0 returned 100%
    64000:  199:        printf("Before: %d\tAfter: %d\n", before, after);
call    0 returned 100%
    64000:  200:        fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  201:    }
        -:  202:    else
        -:  203:    {
     2000:  204:        printf("Test: %s failed!\n", test);
call    0 returned 100%
     2000:  205:        printf("Before: %d\tAfter: %d\n", before, after);
call    0 returned 100%
     2000:  206:        fflush(stdout);
call    0 returned 100%
call    1 returned 100%
        -:  207:    }
    66000:  208:}
